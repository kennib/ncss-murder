<article>
	<h2>Murder Tree</h2>

	<svg id="murder-tree">
	</svg>

	<style>
		svg#murder-tree {
			width: 100%;
			height: 400px;
		}

		.pan-zoom {
			cursor: move;
		}

		.node circle {
			cursor: pointer;
			fill: #fff;
			stroke: #ad213a;
			stroke-width: 1.5px;
		}

		.node circle.closed {
			fill:  #ad213a;
		}

		.node text {
			cursor: pointer;
			font-size: 14px;
		}

		path.link {
			fill: none;
			stroke:rgba(173, 33, 58, 0.3); 
			stroke-width: 1.5px;
		}
	</style>

	<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
	<script src="/static/js/lib/d3.layout.js" charset="utf-8"></script>

	<script>
		var svg = d3.select('svg#murder-tree');

		var m = [20, 120, 20, 120],
			w = svg.node().offsetWidth - m[1] - m[3],
			h = svg.node().offsetHeight - m[0] - m[2],
			i = 0,
			root;

		// Contains zoomable vis
		var zoomable = svg.append('svg:g')
			.call(d3.behavior.zoom().scaleExtent([1, 8]).on('zoom', zoom));
		
		// Contains visualisation
		var vis = zoomable.append('svg:g')
			.attr('width', w)
			.attr('height', h)
			.attr('transform', 'translate(' + m[3] + ',' + m[0] + ')');

		// Detects zooming/panning
		vis.append('svg:rect')
			.attr('class', 'pan-zoom')
			.attr('fill-opacity', 0)
			.attr('width', svg.node().offsetWidth)
			.attr('height', svg.node().offsetHeight);
			
		function zoom() {
		  vis.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
		};

		var tree = d3.layout.tree()
			.size([h, w]);

		var diagonal = d3.svg.diagonal()
			.projection(function(d) { return [d.y, d.x]; });

		d3.json('/murder?game={{ game_id }}', function(murders) {
			// Create the root of the tree
			var murderTree = {
				name: 'Alive',
			};
			
			// Get a map of players
			var murderers = murders.map(function(murder) {
				return {name: murder.murderer};
			});
			var victims = murders.map(function(murder) {
				return {name: murder.victim};
			});
			var playerMap = d3.map(murderers.concat(victims), function(player) {
				return player.name;
			});
			var players = playerMap.values();

			// Construct the tree of murders
			murders.forEach(function(murder) {
				var murderer = playerMap.get(murder.murderer);
				var victim = playerMap.get(murder.victim);

				// Add victim to murderer's children
				if (murderer.children === undefined)
					murderer.children = [];
				murderer.children.push(victim);

				victim.dead = true;
			});
			
			// Get alive players
			murderTree.children = players.filter(function(player) {
				return !player.dead;
			})

			root = murderTree;
			root.x0 = h / 2;
			root.y0 = 0;

			function toggleAll(d) {
				if (d.children) {
					d.children.forEach(toggleAll);
					toggle(d);
				}
			}

			update(root);
		});

		function update(source) {
			var duration = d3.event && d3.event.altKey ? 5000 : 500;

			// Compute the new tree layout.
			var nodes = tree.nodes(root).reverse();

			// Normalize for fixed-depth.
			nodes.forEach(function(d) { d.y = d.depth * 180; });

			// Update the nodes…
			var node = vis.selectAll("g.node")
				.data(nodes, function(d) { return d.id || (d.id = ++i); });

			// Enter any new nodes at the parent's previous position.
			var nodeEnter = node.enter().append("svg:g")
				.attr("class", "node")
				.attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
				.on("click", function(d) { toggle(d); update(d); });

			nodeEnter.append("svg:circle")
				.attr("r", 1e-6)
				.classed("closed", function(d) { return d._children; });

			nodeEnter.append("svg:text")
				.attr("x", function(d) { return d.children || d._children ? -10 : 10; })
				.attr("dy", ".35em")
				.attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
				.text(function(d) { return d.name; })
				.style("fill-opacity", 1e-6);

			// Transition nodes to their new position.
			var nodeUpdate = node.transition()
				.duration(duration)
				.attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

			nodeUpdate.select("circle")
				.attr("r", 4.5)
				.attr('class', function(d) { return d._children ? 'closed' : ''; });

			nodeUpdate.select("text")
				.style("fill-opacity", 1);

			// Transition exiting nodes to the parent's new position.
			var nodeExit = node.exit().transition()
				.duration(duration)
				.attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
				.remove();

			nodeExit.select("circle")
				.attr("r", 1e-6);

			nodeExit.select("text")
				.style("fill-opacity", 1e-6);

			// Update the links…
			var link = vis.selectAll("path.link")
				.data(tree.links(nodes), function(d) { return d.target.id; });

			// Enter any new links at the parent's previous position.
			link.enter().insert("svg:path", "g")
				.attr("class", "link")
				.attr("d", function(d) {
					var o = {x: source.x0, y: source.y0};
					return diagonal({source: o, target: o});
				})
			.transition()
				.duration(duration)
				.attr("d", diagonal);

			// Transition links to their new position.
			link.transition()
				.duration(duration)
				.attr("d", diagonal);

			// Transition exiting nodes to the parent's new position.
			link.exit().transition()
				.duration(duration)
				.attr("d", function(d) {
					var o = {x: source.x, y: source.y};
					return diagonal({source: o, target: o});
				})
				.remove();

			// Stash the old positions for transition.
			nodes.forEach(function(d) {
				d.x0 = d.x;
				d.y0 = d.y;
			});
		}

		// Toggle children.
		function toggle(d) {
			if (d.children) {
				d._children = d.children;
				d.children = null;
			} else {
				d.children = d._children;
				d._children = null;
			}
		}
	</script>
</article>
